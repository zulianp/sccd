#!/usr/bin/env python3

import sympy as sp
from sympy.printing.c import C99CodePrinter

# Create scalar version of bisect tuv[3] = {t, u, v}, no structs no buffers just inout parameters
# Follow the paradigm in numerr.py, tuv.py and narrowphase.py
# This generator emits a single function that splits the chosen dimension and
# returns 1 if either half is degenerate (lower >= upper) along the split dim.

class SCCDPrinter(C99CodePrinter):
    # No special intrinsics are required here, but we maintain parity if needed later
    pass

_PRINTER = SCCDPrinter()

def ccode(expr):
    return _PRINTER.doprint(expr)

def gen_split_function(name: str, axis: str):
    # Use SymPy to build mid and degeneracy on abstract symbols
    l_old, u_old = sp.symbols("l_old u_old", real=True)
    mid_expr = (l_old + u_old) / 2
    deg_expr = sp.Or(sp.Ge(l_old, mid_expr), sp.Ge(mid_expr, u_old))
    reps, reduced = sp.cse([mid_expr, deg_expr], symbols=sp.numbered_symbols("ssa"), optimizations="basic")
    mid_s, deg_s = reduced

    # Pointers for the selected axis
    if axis == "t":
        L1, U1, L2, U2 = "t1_l", "t1_u", "t2_l", "t2_u"
    elif axis == "u":
        L1, U1, L2, U2 = "u1_l", "u1_u", "u2_l", "u2_u"
    else:
        L1, U1, L2, U2 = "v1_l", "v1_u", "v2_l", "v2_u"

    args = [
        f"T * const SCCD_RESTRICT {L1}", f"T * const SCCD_RESTRICT {U1}",
        f"T * const SCCD_RESTRICT {L2}", f"T * const SCCD_RESTRICT {U2}",
    ]

    body = []
    body.append(f"template<typename T> int {name}({', '.join(args)}) {{")
    body.append(f"  const T l_old = *{L1};")
    body.append(f"  const T u_old = *{U1};")
    for sym, expr in reps:
        body.append(f"  const T {str(sym)} = {ccode(expr).replace('l_old', 'l_old').replace('u_old','u_old')};")
    body.append(f"  const T mid = {ccode(mid_s)};")
    # In-place modifications: only change what needs splitting
    body.append(f"  *{U1} = mid;")
    body.append(f"  *{L2} = mid;")
    body.append(f"  return ({ccode(deg_s)}) ? 1 : 0;")
    body.append("}")
    return "\n".join(body)

if __name__ == "__main__":
    print("/* Generated by SymPy; requires <math.h> for division */")
    print(gen_split_function("split_t", "t"))
    print()
    print(gen_split_function("split_u", "u"))
    print()
    print(gen_split_function("split_v", "v")) 
# Reference code
# __device__ inline bool sum_less_than_one(const Scalar &num1,
#                                          const Scalar &num2) {
# #ifdef SCALABLE_CCD_USE_DOUBLE
#   return num1 + num2 <= 1 / (1 - DBL_EPSILON);
# #else
#   return num1 + num2 <= 1 / (1 - FLT_EPSILON);
# #endif
# }
# template <bool is_vf>
# __device__ inline bool bisect(const CCDDomain &domain, const int split,
#                               const Scalar *const toi,
#                               CCDBuffer *const buffer) {
#   const SplitInterval halves(domain.tuv[split]);

#   if (halves.first.lower >= halves.first.upper ||
#       halves.second.lower >= halves.second.upper) {
#     return true;
#   }

#   buffer->push(domain).tuv[split] = halves.first;

#   if (split == 0) {
#     if (halves.second.lower <= *toi) {
#       buffer->push(domain).tuv[0] = halves.second;
#     }
#   } else {
#     if constexpr (is_vf) {
#       if (split == 1) {
#         // check if u+v<=1
#         if (sum_less_than_one(halves.second.lower, domain.tuv[2].lower)) {
#           buffer->push(domain).tuv[1] = halves.second;
#         }
#       } else if (split == 2) {
#         // check if u+v<=1
#         if (sum_less_than_one(halves.second.lower, domain.tuv[1].lower)) {
#           buffer->push(domain).tuv[2] = halves.second;
#         }
#       }
#     } else {
#       buffer->push(domain).tuv[split] = halves.second;
#     }
#   }

#   return false;
# }